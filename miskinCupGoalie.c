#pragma config(Sensor, S1,     backIR,        sensorI2CCustom)
#pragma config(Sensor, S2,     frontIR,         sensorI2CCustom)
#pragma config(Sensor, S3,     compass,        sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     UltraBa,        sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          frontleft,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          frontright,    tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorC,          backleft,      tmotorEV3_Medium, openLoop, reversed, encoder)
#pragma config(Motor,  motorD,          backright,     tmotorEV3_Medium, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
#include "PF_Motors.h"
#include "PF_Motors.c"
#define COMP_MULTI 0.1 //1:.0.75, 2:
int ultra;
int ballDir;
int target;
int speed = 100;
int zero = 0;
int set = 30;
int backdis = 50;
float correction;
int motorSpeeds[18][4] = { //Defining movement
	{ -speed,speed,speed,-speed}, // Forward 0
	{ -speed,set,set,-speed}, // Forward-Right 1
	{ -speed,-speed,-speed,-speed}, // Right 2
	{ set,-speed,-speed,set}, // Backward-Right 3
	{ speed,-speed,-speed,speed}, // Backward 4
	{ speed,-set,-set,speed}, // Backward-Left 5 // Front Left
	{speed,speed,speed,speed}, // Left 6
	{-set,-speed,speed,-set}, // Forward-Left 7
	{zero,zero,zero,zero}, // Still 8
	{ -speed,speed,speed,-speed}, // Forward 0
	{ -speed,set,set,-speed}, // Forward-Right 1
	{ -speed,-speed,-speed,-speed}, // Right 2
	{ set,-speed,-speed,set}, // Backward-Right 3
	{ speed,-speed,-speed,speed}, // Backward 4
	{ speed,-set,-set,speed}, // Backward-Left 5 // Front Left
	{speed,speed,speed,speed}, // Left 6
	{-set,-speed,speed,-set}, // Forward-Left 7
	{zero,zero,zero,zero}, // Still 8
};
int motorVal[4] = {zero, zero, zero, zero};
float max(float a, float b) {
	return a > b? a : b;
}
float caluculateCorrection(int target, int current) {
	float correction = (target - current) * 2;
	if (correction > 180) {
		correction -= 360;
		} else if (correction < -180) {
		correction += 360;
	}

	// Ensure the correction stays within a 10-degree range of the target
	if (correction > 10) {
		correction = 10;
		} else if (correction < -10) {
		correction = -10;
	}

	correction *= COMP_MULTI;
	return correction;
}


int calculateBallDir(int frontStr, int backStr, int frontDir, int backDir) { //Change 1 & 1zero if IR messes up
	int ballDir;
	if(frontStr >= backStr){
		switch(frontDir) {
		case 1:
			ballDir = 6;
			break;
		case 2:
			ballDir = 6;
			break;
		case 3:
			ballDir = 6;
			break;
		case 4:
			if(ultra > backdis) {
				ballDir = 4;}
			else {
				ballDir = 7;
			}
			break;
		case 5:
			if(ultra > backdis) {
				ballDir = 4; }
			else {
				ballDir = 0;
			}
			break;
		case 6:
			if (ultra > backdis) {
				ballDir = 4; }
			else {
				ballDir = 1;
			}
			break;
		case 7:
			ballDir = 2;
			break;
		case 8:
			ballDir = 2;
			break;
		case 9:
			ballDir = 2;
			break;
		default:
			ballDir = 4;
		}
	}
	else
	{
		switch(backDir) {
		case 1:
			ballDir = 4;
			break;
		case 2:
			ballDir = 4;
			break;
		case 3:
			ballDir = 4;
			break;
		case 4:
			ballDir = 2;
			break;
		case 5:
			ballDir = 2;
			break;
		case 6:
			ballDir = 2;
			break;
		case 7:
			ballDir = 2;
			break;
		case 8:
			ballDir = 4;
			break;
		case 9:
			ballDir = 4;
			break;
		default:
			if(ultra > 75) {
				ballDir = 4;
			}
			ballDir = 8;
		}
	}
	return ballDir;
}
void moving(int ballDir, float correction) { //Hard code //(int ballDir, float correction) {
	for(int i = zero; i < 4; i++) {
		motorVal[i] = motorSpeeds[ballDir][i];
		if(i > 1) {
			motorVal[i] += correction;
			} else {
			motorVal[i] -= correction;
		}
	}
	float highestVal = max(abs(motorVal[0]), abs(motorVal[1]));
	highestVal = max(highestVal, abs(motorVal[2]));
	highestVal = max(highestVal, abs(motorVal[3]));
	if(highestVal > 100) {
		if(highestVal != 0) {
			for(int i = 0; i <= 3; i++) {
				motorVal[i] /= highestVal;
				motorVal[i] *= 100;
			}
		}
	}
	motorIn.structure.A = motorVal[0]; //Convert
	motorIn.structure.B = motorVal[1];
	motorIn.structure.C = motorVal[2];
	motorIn.structure.D = motorVal[3];
}
task main() { //This section works fine
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;
	initSensor(&irSeeker1, frontIR);
	initSensor(&irSeeker2, backIR);
	target = SensorValue[S3];
	int current = target;
	for(int i = 0; i < 4; i++) {
		motorIn.array[i] = 0;
	}
	initPFMotors();
	startMotorTask();
	bool ignoreLoop = false;
	while(true) {
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);
		ultra = SensorValue[S4];
		current = SensorValue[S3];
		ballDir = calculateBallDir(irSeeker1.enhStrength, irSeeker2.enhStrength, irSeeker1.acDirection, irSeeker2.acDirection);
		correction = caluculateCorrection(target, current);
		moving(ballDir, correction);
		writeDebugStream("1,2 %4d %4d %4d\n", current);
		if(ultra == 255 || ultra < 2.9) {
			ignoreLoop = true;
			motorIn.structure.A = -speed;
			motorIn.structure.B = speed;
			motorIn.structure.C = speed;
			motorIn.structure.D = -speed;
			wait1Msec(700);
			ignoreLoop = false;
		}
	}
	if (!ignoreLoop) {
		//test
	}
}
